Итак, представляю вам новую версию Mail::Lite

Эта версия была написана с нуля.

Каждое правило состоит из:
1) идентификатора правила
    У этого поля есть специальный формат:
    *	если идентификатор начинается с подчёркивания то правило применяется только как звено цепочки обработки (Chain)
    *	логическим разделителем является `.'
2) поля match:
    Письмо будет обработано правилом если оно совпадёт с условиями в этом поле

    Условия имеют следующий вид:
	<поле>: <что>
    <поле> -- 'body', либо название поля в заголовке email.
    <что> -- правило, которому должно соответствовать поле, может быть:
	* строкой: будет произведено сопостовление regexp'у.
	* массивом: каждое правило должно совпасть ( оператор 'AND' )
	* хэшем с единственным ключом: 'or', 'and', или 'not': к элементу будет применён данный логичский модификатор. В случае 'or' или 'and' элементом хэша должен быть массив.

    Операции допускают вложенность, например: 
    match:
	body:
	    - or: 
		- not: 'seriously'
		- 'hello'
    читается как "или встречается hello или НЕ встречается seriously'

3) поля processors:
    массив процессоров для данного письма.
    процессоры бывают следующих видов:
	1) filter -- фильтрует тело письма
	    принимает параметр filters -- массив фильтров: элементы массива --
	    * строки (подставятся в s/$строка//g)
	    * массивы из двух элементов (подставятся в s/$первый/$второй/g)

	  Пример: # Обрезает все лишние заголовки.
	    - processor: filter
	      filters:
		- '(?s).*New object created:'
		- '(?s)Thank [yY]ou.*'
	2) regexp -- помещает выбранные поля в hash
	    принимает параметр regexps -- массив хэшей:
	     значение -- regexp, который будет применён для получения значения в результатирующий хэш
	     ключ имеет формат <имя в хэше>=~<поле откуда брать>, 
		где <поле> либо 'body', либо имя поля в заголовке
		специальное <имя в хэше> $1 обозначает, что в качестве ключа в результатирующем хэше будет использован $1, а в качестве значения - $2

	3) split -- делит сообщение на части по заданому separator'у.
	    begin: (regexp) -- всё до этого regexp'а (включая сам его) будет отмечено как заголовок письма
	    end: (regexp) -- всё после этого regexp'а (включительно) будет отмечено как конец письма
	    separator: (regexp) будет использован для разделения частей сообщения
	    emulate: 1|0 -- эмулировать ли полное тело письма. если 1 -- к части письма будет добавлен заголовок и конец.
	4) chain -- передаёт набор сообщений, полученных от split на обработку к правилам имеющим имя вида:
	    _<имя оригинального правила>.*
